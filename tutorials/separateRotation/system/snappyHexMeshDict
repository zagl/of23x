// -*- C++ -*-
// File generated by PyFoam - sorry for the ugliness

FoamFile
{
 version 2.0;
 format ascii; 	
 class dictionary; 	
 object autoHexMeshDict; 	
}

#include "./system/configDict";

#codeStream
{
    codeInclude
    #{
        #include "vectorField.H"
        #include "Tuple2.H"
        #include "POSIX.C"
    #};

    code
    #{


dictionary configDict = dict.subDict("config");
vectorField boundingBox = configDict.lookup("boundingBox");
scalar globalLength  = readScalar(configDict.lookup("elementLength"));

dictionary snappyHexMesh;
dictionary geometry;
dictionary refinementSurfaces;
dictionary refinementRegions;

fileName constantDir("constant");
fileName triSurfaceDir(constantDir/"triSurface");
fileNameList triSurfaces = readDir(triSurfaceDir);
HashTable<word> surfFileNames;
forAll( triSurfaces, surfI )
{
    surfFileNames.insert( triSurfaces[surfI].lessExt(), triSurfaces[surfI] );
}

wordList geomTypes
(
    IStringStream("(solids blanks baffles rotations refinements)")()
);

forAll( geomTypes, i )
{
    word geomType = geomTypes[i];
    forAllConstIter(dictionary, configDict.subDict(geomType), iter)
    {
        const dictionary& dict = iter().dict();
        word name = iter().keyword();

        dictionary geomDict;
        geomDict.add("name", name);
        geomDict.add("type", "triSurfaceMesh");
        geometry.add(surfFileNames[name], geomDict);

        scalar localLength = readScalar(dict.lookup("elementLength"));
        label refinementLevel = int(log(globalLength/localLength) / log(2.0) + 0.5);

        if ( geomType == "refinements" )
        {
            dictionary region;
            List<Tuple2<label, scalar> > levels(1);
            levels[0] = Tuple2<label, scalar>(1.0, refinementLevel);
            region.add("levels", levels);
            region.add("mode", "inside");
            refinementRegions.add(name, region);
        }
        else
        {
            dictionary surface;
            labelList level(2, refinementLevel);
            surface.add("level", level);
            if ( geomType == "solids" )
            {
                surface.add("cellZone", name);
                surface.add("faceZone", name);
                surface.add("cellZoneInside", "inside");
            }
            else if ( geomType == "baffles" )
            {
                surface.add("faceZone", name);
            }
            refinementSurfaces.add(name, surface);
        }
    }
}

vector locationInMesh = boundingBox[0] + vector(0.00001, 0.00001, 0.00001);

snappyHexMesh.add("geometry", geometry);
snappyHexMesh.add("refinementSurfaces", refinementSurfaces);
snappyHexMesh.add("refinementRegions", refinementRegions);
snappyHexMesh.add("locationInMesh", locationInMesh);

dictionary config;
config.add("snappyHexMesh", snappyHexMesh);

os  << "config" << config;
Info<< "config" << config;


    #}; // End code

}; // End codeStream



castellatedMesh true;

snap true; 	

addLayers false; 	

geometry
{
    $:config.snappyHexMesh.geometry
}

castellatedMeshControls
{
  maxLocalCells 100000;
  maxGlobalCells 2000000; 	
  minRefinementCells 10; 	
  nCellsBetweenLevels 2; 	
  features
    (
    ); 	
  refinementSurfaces
  {
    $:config.snappyHexMesh.refinementSurfaces
  } 	
  resolveFeatureAngle 30; 	
  refinementRegions
  {
    $:config.snappyHexMesh.refinementRegions
  } 	
  locationInMesh $:config.snappyHexMesh.locationInMesh;
  allowFreeStandingZoneFaces true; 	
} 	

snapControls
{
  nSmoothPatch 1;
  tolerance 1.0; 	
  nSolveIter 30; 	
  nRelaxIter 5; 	
  nFeatureSnapIter 5; 	
  implicitFeatureSnap true; 	
  explicitFeatureSnap false; 	
  multiRegionFeatureSnap true; 	
} 	

addLayersControls
{
  relativeSizes true;
  layers
  {
    maxY
    {
      nSurfaceLayers 3;
    }
  } 	
  expansionRatio 1.3; 	
  finalLayerThickness 1; 	
  minThickness 0.1; 	
  nGrow 0; 	
  featureAngle 30; 	
  nRelaxIter 3; 	
  nSmoothSurfaceNormals 1; 	
  nSmoothNormals 3; 	
  nSmoothThickness 2; 	
  maxFaceThicknessRatio 0.5; 	
  maxThicknessToMedialRatio 1; 	
  minMedianAxisAngle 90; 	
  nBufferCellsNoExtrude 0; 	
  nLayerIter 50; 	
} 	

meshQualityControls
{
  maxNonOrtho 65;
  maxBoundarySkewness 20; 	
  maxInternalSkewness 4; 	
  maxConcave 80; 	
  minVol 0; 	
  minTetQuality 1e-30; 	
  minArea -1; 	
  minTwist 0.02; 	
  minDeterminant 0.001; 	
  minFaceWeight 0.02; 	
  minVolRatio 0.01; 	
  minTriangleTwist -1; 	
  nSmoothScale 4; 	
  errorReduction 0.75; 	
} 	

debug 0; 	

mergeTolerance 1e-06; 	

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
