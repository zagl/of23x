/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  2.3.0                                 |
|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      configCode;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#include "./system/configDict";

#codeStream
{
    codeOptions
    #{
    #};

    codeLibs
    #{
    #};

    codeInclude
    #{
        #include "vectorField.H"
    #};

    code
    #{
        dictionary configDict = dict.subDict("config");
        scalar elementLength  = readScalar(configDict.lookup("elementLength"));
        scalar elementGradient = readScalar(configDict.lookup("elementGradient"));
        vectorField boundingBox = configDict.lookup("boundingBox");
        vectorField distance = configDict.lookup("fluidDistance");

        vectorField l(4);
        vectorField divisions(3);
        vectorField edgeGradient(3);
        for ( int i=0; i<3; i++ )
        {
            l[0][i] = boundingBox[0][i] - distance[0][i];
            l[1][i] = boundingBox[0][i];
            l[2][i] = boundingBox[1][i];
            l[3][i] = boundingBox[1][i] + distance[1][i];

            divisions[0][i] = int(log((distance[0][i])/elementLength
                * (elementGradient - 1) + 1)/log(elementGradient ) + 0.5);

            divisions[1][i] = int((boundingBox[1][i] - boundingBox[0][i])
                / elementLength  + 0.5);

            divisions[2][i] = int(log((distance[1][i])/elementLength 
                * (elementGradient - 1) + 1)/log(elementGradient ) + 0.5);

            edgeGradient[0][i] = 1/pow(elementGradient, divisions[0][i]-1);
            edgeGradient[1][i] = 1;
            edgeGradient[2][i] = pow(elementGradient, divisions[2][i]-1);
        }

        vectorField vertices;
        for ( int k=0; k<4; k++ )
        {
            for ( int j=0; j<4; j++ )
            {
                for ( int i=0; i<4; i++ )
                {
                    vector p(l[i].x(), l[j].y(), l[k].z());
                    vertices.append(p);
                }
            }
        }

        wordList blocks;
        for ( int k=0; k<3; k++ )
        {
            for ( int j=0; j<3; j++ )
            {
                for ( int i=0; i<3; i++ )
                {
                    labelList corners(8);
                    for ( int n=0; n<8; n++ )
                    {
                        label corner = i+((n+1)>>1&1) + 4*(j+(n>>1&1))
                            + 16*(k+(n>>2));
                        corners[n] = corner;
                    }
                    vector division
                    (
                        divisions[i].x(),
                        divisions[j].y(),
                        divisions[k].z()
                    );
                    vector gradient
                    (
                        edgeGradient[i].x(),
                        edgeGradient[j].y(),
                        edgeGradient[k].z()
                    );

                    OStringStream block;
                    block << "hex " << corners << division 
                        << " simpleGrading " << gradient;
                    blocks.append(block.str());
                }
            }
        }

        dictionary blockMesh;
        blockMesh.add("blocks", blocks);
        blockMesh.add("vertices", vertices);

        dictionary config;
        config.add("blockMesh", blockMesh);

        os  << "config" << config;
    #};
};


// ************************************************************************* //
